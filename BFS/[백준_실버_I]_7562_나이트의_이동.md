# [백준 실버 I] 7562: 나이트의 이동

> 🏷️ #너비 우선 탐색 | #그래프 이론 | #그래프 탐색 | #최단 경로 | #격자 그래프

> 🔗 www.acmicpc.net
https://www.acmicpc.net/problem/7562

---

---

## 📋 문제

체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?

---

## 📥 입력

입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.


각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, ..., l-1} × {0, ..., l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.

---

## 📤 출력

각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.

---

## 💻 예제

### 예제 입력 1

```plain text
3
8
0 0
7 0
100
0 0
30 50
10
1 1
1 1
```

### 예제 출력 1

```plain text
5
28
0
```

---

## ✏️ 풀이

```python
from collections import deque
import sys
input = sys.stdin.readline

n_cases = int(input())

# print(f'n_cases: {n_cases}')

def visualize_graph(graph):
    for i in range(len(graph[0])):
        print(graph[i])
    
    print()

def bfs(sx, sy, ex, ey):
    queue = deque([(sx, sy, 0)])
    # check visited
    graph[sx][sy] = True

    while queue:
        cur_x, cur_y, cur_cnt = queue.popleft()

        # print(f'cur_x: {cur_x}, cur_y: {cur_y}')

        if cur_x == ex and cur_y == ey:
            break
        
        dx = [-2, -1, 1, 2, 2, 1, -1, -2]
        dy = [1, 2, 2, 1, -1, -2, -2, -1]

        for i in range(8):
            n_x = cur_x + dx[i]
            n_y = cur_y + dy[i]

            if 0 <= n_x < l and 0 <= n_y < l:
                if not graph[n_x][n_y]:
                    # check visited
                    graph[n_x][n_y] = True    
                    queue.append((n_x, n_y, cur_cnt+1))

    print(cur_cnt)

# Main loop
for i in range(n_cases):
    # Create graph
    l = int(input())
    graph = []
    for i in range(l):
        graph.append([False] * l)

    # Get strat and end points
    s_x, s_y = map(int, input().split())
    e_x, e_y = map(int, input().split())

    # print(f's_x: {s_x}, s_y: {s_y}')
    # print(f'e_x: {e_x}, e_y: {e_y}')

    bfs(s_x, s_y, e_x, e_y)
```
